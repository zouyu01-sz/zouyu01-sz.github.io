<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[正则有关方法]]></title>
    <url>%2F2018%2F11%2F12%2F%E6%AD%A3%E5%88%99%E6%9C%89%E5%85%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[正则的方法和与正则有关的方法 共有6个，字符串实例4个，正则实例2个： 1234567891011String#searchString#splitString#matchString#replaceRegExp#testRegExp#exec 1.search() 定义：正则去匹配字符串，如果匹配成功，就返回匹配成功的位置，匹配失败就返回-1. 例子： 1234var regex = /\d/;var string = "abc123";console.log( string.search(regex) );// =&gt; 3 2.split 定义：split()方法把原字符串分割成子字符串组成数组，并返回该数组。 语法：str.split(separator, limit) 两个参数均是可选的，其中 separator 表示分隔符，它可以是字符串也可以是正则表达式。如果忽略 separator，则返回的数组包含一个由原字符串组成的元素。如果 separator 是一个空串，则 str 将会被分割成一个由原字符串中字符组成的数组。limit 表示从返回的数组中截取前 limit 个元素，从而限定返回的数组长度。 1234567var regex = /\D/console.log( "2017/06/26".split(regex) )console.log( "2017.06.26".split(regex) )console.log( "2017-06-26".split(regex) )// =&gt; ["2017", "06", "26"]// =&gt; ["2017", "06", "26"]// =&gt; ["2017", "06", "26"] 3.match 定义：match() 方法用于测试字符串是否支持指定正则表达式的规则，即使传入的是非正则表达式对象，它也会隐式地使用new RegExp(obj)将其转换为正则表达式对象。 语法：str.match(regexp) 该方法返回包含匹配结果的数组，如果没有匹配项，则返回 null 匹配原则：匹配成功就会结束，如果想继续全部匹配，加标识g 描述 若正则表达式没有 g 标志，则返回同 RegExp.exec(str) 相同的结果。而且返回的数组拥有一个额外的 input 属性，该属性包含原始字符串，另外该数组还拥有一个 index 属性，该属性表示匹配字符串在原字符串中索引（从0开始）。 若正则表达式包含 g 标志，则该方法返回一个包含所有匹配结果的数组，没有匹配到则返回 null。 12345var regex = /^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;)$/;var string = "2017-06-26";console.log( string.match(regex) );// =&gt;["2017-06-26", "2017", "06", "26", index: 0, input: "2017-06-26"]// =&gt; 3 4.replace 语法：str.replace( regexp | substr, newSubStr | function[, flags] ) 参数： regexp: 一个 RegExp 对象. 该正则所匹配的内容会被第二个参数的返回值替换掉。 substr: 一个要被 newSubStr 替换的字符串. newSubStr: 替换掉第一个参数在原字符串中的匹配部分. 该字符串中可以内插一些特殊的变量名. function: 一个用来创建新子字符串的函数, 该函数的返回值将替换掉第一个参数匹配到的结果. 该函数的参数描-述请参考 指定一个函数作为参数 小节. flags: 注意：flags 参数在 v8 内核（Chrome and NodeJs）中不起作用. 方法中使用 flags 参数不是符合标准的并且不赞成这样做. 5.test 说明：正则去匹配字符串，匹配成功，返回true，匹配失败，返回false 案例： 1234var regex = /\d/;var string = "abc123";console.log( regex.test(string) );// =&gt; true More info: Generating More info: Writing More info: Server 这篇文章对正则的细枝末节都有详细的介绍，我摘抄了部分重要的代码，和总结了6个方法。 剩下的匹配规则、关键字等，以后会一一补充。]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue入门到精通]]></title>
    <url>%2F2018%2F05%2F07%2FVue%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%2F</url>
    <content type="text"><![CDATA[前言本文以前端面试官的角度出发，对 Vue 框架中一些重要的特性、框架的原理以问题的形式进行整理汇总，意在帮助作者及读者自测下 Vue 掌握的程度。 1、说说你对 SPA 单页面的理解，它的优缺点分别是什么？SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。 优点： 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染； 基于上面一点，SPA 相对对服务器压力小； 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理； 缺点： 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载； 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理； SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。 2、v-show 与 v-if 有什么区别？v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。 所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。 3、Class 与 Style 如何动态绑定？ Class 可以通过对象语法和数组语法进行动态绑定： 对象语法： 123456&lt;div :class=&quot;&#123; active: isActive, &apos;text-danger&apos;: hasError &#125;&quot;&gt;&lt;/div&gt;data: &#123; isActive: true, hasError: false&#125; 数组语法： 123456&lt;div :class=&quot;[isActive ? activeClass : &apos;&apos;, errorClass]&quot;&gt;&lt;/div&gt;data: &#123; activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos;&#125; Style 也可以通过对象语法和数组语法进行动态绑定： 对象语法：123456&lt;div :style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;data: &#123; activeColor: &apos;red&apos;, fontSize: 30&#125; 数组语法： 12345678910&lt;div :style=&quot;[styleColor, styleSize]&quot;&gt;&lt;/div&gt;data: &#123; styleColor: &#123; color: &apos;red&apos; &#125;, styleSize:&#123; fontSize:&apos;23px&apos; &#125;&#125; 4、怎样理解 Vue 的单向数据流？所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定 ：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。 额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit派发一个自定义事件，父组件接收到后，由父组件修改。 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值： 123456props: [&apos;initialCounter&apos;],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125; 这个 prop 以一种原始的值传入且需要进行转换。 在这种情况下，最好使用这个 prop 的值来定义一个计算属性 123456props: [&apos;size&apos;],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; 5、computed 和 watch 的区别和运用的场景？computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值； watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作； 运用场景： 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算； 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 6、直接给一个数组项赋值，Vue 能检测到变化吗？由于 JavaScript 的限制，Vue 不能检测到以下数组的变动 7、谈谈你对 Vue 生命周期的理解？1、creating 状态–vue 实例被创建的过程2、mounting 状态–挂到到真实的 DOM 节点3、updating 状态–如果 data 中的数据改变就会触发对应组件的重新渲染4、destroying 状态–实例销毁| 方法名 | 状态 | 含义 || —— | —— | —— || beforeCreate | creating 状态 | 实例创建之前调用 ||created| creating 状态| 实例创建成功，此时 data 中的数据显示出来了||beforeMount |mounting 状态 |数据中的 data 在模版中先占一个位置||mounted |mounting 状态 |模版中的 data 数据直接显示出来了||beforeUpdate| updating 状态| 当 data 数据发生变化调用，发生在虚拟 DOM 重新渲染和打补丁之前||updated| updating 状态| 数据更改导致的虚拟 DOM 重新渲染和打补丁||beforeDestroy| destroying 状态 |在 vue 实例销毁之前调用，此时实例任然可用||destroyed| destroying 状态| 在 vue 实例销毁之后调用| 8、在哪个生命周期内调用异步请求？可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点： 能更快获取到服务端数据，减少页面 loading 时间； ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性 9、在什么阶段才能访问操作DOM？mounted 10、父组件可以监听到子组件的生命周期吗？比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现： 1234567// Parent.vue&lt;Child @mounted=&quot;doSomething&quot;/&gt; // Child.vuemounted() &#123; this.$emit(&quot;mounted&quot;);&#125; 以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示： 123456789101112131415// Parent.vue&lt;Child @hook:mounted=&quot;doSomething&quot; &gt;&lt;/Child&gt;doSomething() &#123; console.log(&apos;父组件监听到 mounted 钩子函数 ...&apos;);&#125;, // Child.vuemounted()&#123; console.log(&apos;子组件触发 mounted 钩子函数 ...&apos;);&#125;, // 以上输出顺序为：// 子组件触发 mounted 钩子函数 ...// 父组件监听到 mounted 钩子函数 ... 当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。 11、谈谈你对 keep-alive 的了解？keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性： 一般结合路由和动态组件一起使用，用于缓存组件； 提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高； 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。 12、组件中 data 为什么是一个函数？为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？ 123456789101112131415// datadata() &#123; return &#123; message: &quot;子组件&quot;, childName:this.name &#125;&#125;// new Vuenew Vue(&#123; el: &apos;#app&apos;, router, template: &apos;&lt;App/&gt;&apos;, components: &#123;App&#125;&#125;) 因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。 13、v-model 的原理？我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件： text 和 textarea 元素使用 value 属性和 input 事件； checkbox 和 radio 使用 checked 属性和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 以 input 表单元素为例： 12345&lt;input v-model=&apos;something&apos;&gt; 相当于&lt;input v-bind:value=&quot;something&quot; v-on:input=&quot;something = $event.target.value&quot;&gt; 如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示： 1234567891011121314父组件：&lt;ModelChild v-model=&quot;message&quot;&gt;&lt;/ModelChild&gt;子组件：&lt;div&gt;&#123;&#123;value&#125;&#125;&lt;/div&gt;props:&#123; value: String&#125;,methods: &#123; test1()&#123; this.$emit(&apos;input&apos;, &apos;小红&apos;) &#125;,&#125;, 14、Vue 组件间通信有哪几种方式？3类通信：父子组件通信、隔代组件通信、兄弟组件通信（1）props / $emit 适用 父子组件通信（2）ref 与 $parent / $children 适用 父子组件通信（3）EventBus （$emit / $on） 适用于 父子、隔代、兄弟组件通信（4）$attrs/$listeners 适用于 隔代组件通信（5）provide / inject 适用于 隔代组件通信（6）Vuex 适用于 父子、隔代、兄弟组件通信 15、你使用过 Vuex 吗？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。 主要包括以下几个模块： State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。 Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。 Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。 Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。 Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。 16、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？（1）hash 模式的实现原理 早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’： 1https://www.word.com#search hash 路由模式的实现主要是基于下面几个特性： URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送； hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换； 可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值； 我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。 （2）history 模式的实现原理 HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示： 12window.history.pushState(null, null, path);window.history.replaceState(null, null, path); history 路由模式的实现主要基于存在下面几个特性： pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ； 我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）； history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。 17、什么是 MVVM？（1）View 层 View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。 （2）Model 层 Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。 （3）ViewModel 层 18、Vue 是如何实现数据双向绑定的？Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示： 19、Vue 中的 key 有什么作用？key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue性能优化]]></title>
    <url>%2F2017%2F10%2F23%2FVue%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言 Vue 框架通过数据双向绑定和虚拟 DOM 技术，帮我们处理了前端开发中最脏最累的 DOM 操作部分， 我们不再需要去考虑如何操作 DOM 以及如何最高效地操作 DOM；但 Vue 项目中仍然存在项目首屏优化、Webpack 编译配置优化等问题，所以我们仍然需要去关注 Vue 项目性能方面的优化，使项目具有更高效的性能、更好的用户体验。本文是作者通过实际项目的优化实践进行总结而来，希望读者读完本文，有一定的启发思考，从而对自己的项目进行优化起到帮助。本文内容分为以下三部分组成： Vue 代码层面的优化； webpack 配置层面的优化； 基础的 Web 技术层面的优化。 一、代码层面的优化1.1、v-if 和 v-show 区分使用场景v-if 是 真正 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show 就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。 所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。 1.2、computed 和 watch 区分使用场景computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值； watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；运用场景： 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算； 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 1.3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-if（1）v-for 遍历必须为 item 添加 key在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。 （2）v-for 遍历避免同时使用 v-ifv-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。 推荐：1234567891011121314&lt;ul&gt; &lt;li v-for="user in activeUsers" :key="user.id"&gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt;computed: &#123; activeUsers: function () &#123; return this.users.filter(function (user) &#123; return user.isActive &#125;) &#125;&#125; 不推荐：12345678&lt;ul&gt; &lt;li v-for="user in users" v-if="user.isActive" :key="user.id"&gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 1.4、长列表性能优化Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。 123456789export default &#123; data:() =&gt; (&#123; users: &#123;&#125; &#125;), async created() &#123; const users = await axios.get("/api/users"); this.users = Object.freeze(users); &#125;&#125; 1.5、事件的销毁Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 如果在 js 内使用 addEventListene 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如： 123456created() &#123; addEventListener('click', this.click, false)&#125;,beforeDestroy() &#123; removeEventListener('click', this.click, false)&#125; 1.6、图片资源懒加载对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件：（1）安装插件 1npm install vue-lazyload --save-dev （2）在入口文件 main.js 中引入并使用 12import VueLazyload from &apos;vue-lazyload&apos;Vue.use(VueLazyload) （3）在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示： 1&lt;img v-lazy=&quot;/static/img/1.png&quot;&gt; 以上为vue-lazyload 插件的简单使用，如果要看插件的更多参数选项，可以查看 vue-lazyload 的 github地址。 1.7、路由懒加载Vue 是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。 路由懒加载：123456const Foo = () =&gt; import(&apos;./Foo.vue&apos;)const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/foo&apos;, component: Foo &#125; ]&#125;) 1.8、第三方插件的按需引入我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 element-ui 组件库为例：（1）首先，安装 babel-plugin-component ： 1npm install babel-plugin-component -D （2）然后，将 .babelrc 修改为： 123456789101112&#123; &quot;presets&quot;: [[&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;]], &quot;plugins&quot;: [ [ &quot;component&quot;, &#123; &quot;libraryName&quot;: &quot;element-ui&quot;, &quot;styleLibraryName&quot;: &quot;theme-chalk&quot; &#125; ] ]&#125; （3）在 main.js 中引入部分需要用到的组件： 12345import Vue from &apos;vue&apos;;import &#123; Button, Select &#125; from &apos;element-ui&apos;; Vue.use(Button) Vue.use(Select) 1.9、优化无限列表性能如果你的应用存在非常长或者无限滚动的列表，那么需要采用 窗口化 的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。你可以参考以下开源项目: &ensp;&ensp;vue-virtual-scroll-list 和 vue-virtual-scroller 来优化这种无限列表的场景的。 1.10、服务端渲染 SSR or 预渲染服务端渲染是指 Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染。（1）服务端渲染的优点： 更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面； 更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间； （2）服务端渲染的缺点： 更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境； 更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源，因此如果你预料在高流量环境下使用，请准备相应的服务器负载，并明智地采用缓存策略。 二、Webpack 层面的优化2.1、Webpack 对图片进行压缩在 vue 项目中除了可以在 webpack.base.conf.js 中 url-loader 中设置 limit 大小来对图片处理，对小于 limit 的图片转化为 base64 格式，其余的不做操作。所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 image-webpack-loader来压缩图片： （1）首先，安装 image-webpack-loader ： 1npm install image-webpack-loader --save-dev （2）然后，在 webpack.base.conf.js 中进行配置： 123456789101112131415161718&#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, use:[ &#123; loader: &apos;url-loader&apos;, options: &#123; limit: 10000, name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;) &#125; &#125;, &#123; loader: &apos;image-webpack-loader&apos;, options: &#123; bypassOnDebug: true, &#125; &#125; ]&#125; 2.2、减少 ES6 转为 ES5 的冗余代码在默认情况下， Babel 插件会在将 ES6 代码转换成 ES5 代码时会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过 require(‘babel-runtime/helpers/createClass’) 的方式导入，这样就能做到只让它们出现一次。babel-plugin-transform-runtime 插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。 （1）首先，安装 babel-plugin-transform-runtime ： 1npm install babel-plugin-transform-runtime --save-dev （2）然后，修改 .babelrc 配置文件为： 123&quot;plugins&quot;: [ &quot;transform-runtime&quot;] 如果要看插件的更多详细内容，可以查看babel-plugin-transform-runtime 的 详细介绍。 2.3、提取公共代码如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题： 相同的资源被重复加载，浪费用户的流量和服务器的成本。 每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。 所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。Webpack 内置了专门用于提取多个Chunk 中的公共部分的插件 CommonsChunkPlugin，我们在项目中 CommonsChunkPlugin 的配置如下： 123456789101112131415161718// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;vendor&apos;, minChunks: function(module, count) &#123; return ( module.resource &amp;&amp; /\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, &apos;../node_modules&apos;) ) === 0 ); &#125;&#125;),// 抽取出代码模块的映射关系new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;manifest&apos;, chunks: [&apos;vendor&apos;]&#125;) 如果要看插件的更多详细内容，可以查看 CommonsChunkPlugin 的 详细介绍。 2.4、模板预编译当使用 DOM 内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。 预编译模板最简单的方式就是使用单文件组件——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。 如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 vue-template-loader，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。 2.5、提取组件的 CSS当使用单文件组件时，组件内的 CSS 会以 style 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段 “无样式内容闪烁 (fouc) ” 。将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。 查阅这个构建工具各自的文档来了解更多： webpack + vue-loader ( vue-cli 的 webpack 模板已经预先配置好) Browserify + vueify Rollup + rollup-plugin-vue 2.6、优化 SourceMap我们在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩、去掉多余的空格、babel编译化后，最终将编译得到的代码会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有 bug的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发来说不好调式定位问题，因此 sourceMap 出现了，它就是为了解决不好调式代码问题的。 2.7、构建结果输出分析Webpack 输出的代码可读性非常差而且文件非常大，让我们非常头疼。为了更简单、直观地分析输出结果，社区中出现了许多可视化分析工具。这些工具以图形的方式将结果更直观地展示出来，让我们快速了解问题所在。接下来讲解我们在 Vue 项目中用到的分析工具：webpack-bundle-analyzer 。我们在项目中 webpack.prod.conf.js 进行配置： 1234if (config.build.bundleAnalyzerReport) &#123; var BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin; webpackConfig.plugins.push(new BundleAnalyzerPlugin());&#125; 执行 $ npm run build –report 后生成分析报告如下： 2.8、Vue 项目的编译优化详细介绍。 三、基础的 Web 技术优化3.1、开启 gzip 压缩gzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip。目前主流的浏览器，Chrome，firefox，IE等都支持该协议。常见的服务器如 Apache，Nginx，IIS 同样支持，gzip 压缩效率非常高，通常可以达到 70% 的压缩率，也就是说，如果你的网页有 30K，压缩之后就变成了 9K 左右 以下我们以服务端使用我们熟悉的 express 为例，开启 gzip 非常简单，相关步骤如下： 安装： 1npm install compression --save 添加代码逻辑： 123var compression = require(&apos;compression&apos;);var app = express();app.use(compression()) 重启服务，观察网络面板里面的 response header，如果看到如下红圈里的字段则表明 gzip 开启成功 ： 3.2、浏览器缓存为了提高用户加载页面的速度，对静态资源进行缓存是非常必要的，根据是否需要重新向服务器发起请求来分类，将 HTTP 缓存规则分为两大类（强制缓存，对比缓存），如果对缓存机制还不是了解很清楚的，可以参考作者写的关于 HTTP 缓存的文章《深入理解HTTP缓存机制及原理》，这里不再赘述。 3.3、CDN 的使用浏览器从服务器上下载 CSS、js 和图片等文件时都要和服务器连接，而大部分服务器的带宽有限，如果超过限制，网页就半天反应不过来。而 CDN 可以通过不同的域名来加载文件，从而使下载文件的并发连接数大大增加，且CDN 具有更好的可用性，更低的网络延迟和丢包率 。 3.4、使用 Chrome Performance 查找性能瓶颈Chrome 的 Performance 面板可以录制一段时间内的 js 执行细节及时间。使用 Chrome 开发者工具分析页面性能的步骤如下。 打开 Chrome 开发者工具，切换到 Performance 面板 点击 Record 开始录制 刷新页面或展开某个节点 点击 Stop 停止录制]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>服务端渲染SSR</tag>
      </tags>
  </entry>
</search>
