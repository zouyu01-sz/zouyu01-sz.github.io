<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[linux下Mysql安装使用]]></title>
    <url>%2F2019%2F05%2F01%2Flinux%E4%B8%8BMysql%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、系统环境 Ubuntu18.04， Mysql 5.7.25二、通过apt 安装MySQL1234#命令1sudo apt-get update#命令2sudo apt-get install mysql-server 三、配置初始化信息1sudo mysql_secure_installation 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Securing the MySQL server deployment.Connecting to MySQL using a blank password.VALIDATE PASSWORD PLUGIN can be used to test passwordsand improve security. It checks the strength of passwordand allows the users to set only those passwords which aresecure enough. Would you like to setup VALIDATE PASSWORD plugin?Press y|Y for Yes, any other key for No: N（选择N，不会进行密码的强校验）Please set the password for root here.New password: Re-enter new password: By default, a MySQL installation has an anonymous user,allowing anyone to log into MySQL without having to havea user account created for them. This is intended only fortesting, and to make the installation go a bit smoother.You should remove them before moving into a productionenvironment.Remove anonymous users? (Press y|Y for Yes, any other key for No) : N（选择N，不删除匿名用户） ... skipping.Normally, root should only be allowed to connect from&apos;localhost&apos;. This ensures that someone cannot guess atthe root password from the network.Disallow root login remotely? (Press y|Y for Yes, any other key for No) : N（选择N，允许root远程连接） ... skipping.By default, MySQL comes with a database named &apos;test&apos; thatanyone can access. This is also intended only for testing,and should be removed before moving into a productionenvironment.Remove test database and access to it? (Press y|Y for Yes, any other key for No) : N（选择N，不删除test数据库） ... skipping.Reloading the privilege tables will ensure that all changesmade so far will take effect immediately.Reload privilege tables now? (Press y|Y for Yes, any other key for No) : Y（选择Y，修改权限立即生效）Success.All done! 查看数据库是否安装成功 1234systemctl status mysql.service //检查数据状态sudo service mysql restart //数据库重启service iptables stop //新手建议先关闭防火墙，免得下一步操作有问题 四、配置访问权限在Ubuntu下MySQL缺省是只允许本地访问的，使用workbench连接工具是连不上的；如果你要其他机器也能够访问的话，需要进行配置： 首先用根用户进入 1sudo mysql -uroot -p 登入root进行其他设置： 12345//创建一个 root账号，密码为123456GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos; WITH GRANT OPTION;FLUSH PRIVILEGES;exit 退出 设置允许远程连接 12cd /etc/mysql/mysql.conf.d sudo vim mysqld.cnf //如下设置其他机器允许连接 五、新建数据库和用户1234##1 创建数据库studentServiceCREATE DATABASE studentService;##2 创建用户teacher(密码admin) 并赋予其studentService数据库的远程连接权限GRANT ALL PRIVILEGES ON teacher.* TO studentService@% IDENTIFIED BY &quot;admin&quot;; 六、修改root用户密码 首先停掉mysql进程服务 1killall -TERM mysqld 连接具体数据库（以 mysql 数据库为例） 1use mysql; 更改root密码 1update mysql.user set authentication_string=password(&apos;1234qwer&apos;) where user=&apos;root&apos;； 注意password（新密码），而且不要加and Host = ‘localhost’这部分，会更改失败。]]></content>
      <categories>
        <category>Linux</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu18.04</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下安装pm2]]></title>
    <url>%2F2019%2F04%2F30%2Flinux%E4%B8%8B%E5%AE%89%E8%A3%85pm2%2F</url>
    <content type="text"><![CDATA[前言对于一个linux新手来说，pm2真的是一大坑，看了网上好多例子，但没有一个能说明白的，本人也是各种尝试和采坑给大家分享下正确经验 pm2安装使用1npm install pm2 -g 执行上面shell命令你以为就可以使用pm2，然并卯 我们来用 pm2 list 跑下 说明：没有配制到全局，虽然安装到全局，不知道为毛，linux下不像windows下能自动创造一个环境变量去实现我们的全局。所以我们需要创建一个linux下的软连接。 解决方法： 12345678910echo $PATH //查看安装路径cd /usr/local/bin //切换安装路径ln -s /usr/local/node-v10.16.3-linux-x64/bin/pm2 /usr/local/bin/ //增加软链接pm2 list ┌──────────┬────┬──────┬─────┬────────┬─────────┬────────┬─────┬─────┬──────┬──────────┐│ App name │ id │ mode │ pid │ status │ restart │ uptime │ cpu │ mem │ user │ watching │└──────────┴────┴──────┴─────┴────────┴─────────┴────────┴─────┴─────┴──────┴──────────┘ ubuntu系统下 使用pm2设置node项目开机自启动 sudo pm2 start ./bin/www sudo pm2 save sudo pm2 startup sudo pm2 save 重启系统试一下：如果不行执行chattr +i /home/XXX/.pm2/dump.pm2再重试一下]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>Ubuntu18.04</tag>
        <tag>node</tag>
        <tag>pm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu18.04安装最新nodejs]]></title>
    <url>%2F2019%2F04%2F28%2Fubuntu18-04%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0nodejs%2F</url>
    <content type="text"><![CDATA[环境ubuntu 18.04 LTS版本 进入官网查找最新下载地址 https://nodejs.org/en/download/ 右键复制源码下载链接 在系统内一次输入以下指令 123456wget https://nodejs.org/dist/v10.16.3/node-v10.16.3-linux-x64.tar.gztar -xvf node-v10.16.3-linux-x64.tar.gz//移动安装位置sudo mv node-v10.16.3-linux-x64 /usr/local 创建软连接 可以在任意路径下执行npm node 12sudo ln -s /usr/local/node-v10.16.3-linux-x64/bin/node /usr/local/bin/node sudo ln -s /usr/local/node-v10.16.3-linux-x64/bin/npm /usr/local/bin/npm 如果你在创建软连的时候，出现npm已经存在,node 已经存在解决方案：删除 /usr/local/bin/目录下的node，npm 12sudo rm -rf /usr/local/bin/nodesudo rm -rf /usr/local/bin/npm 之后再创建软连接，完成。 123node -vnpm -v]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>Ubuntu18.04</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack+shell脚本实现简单的自动化发布]]></title>
    <url>%2F2019%2F02%2F26%2Fwebpack-shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%91%E5%B8%83%2F</url>
    <content type="text"><![CDATA[创建一个deploy.sh 在project下创建deploy.sh。1touch deploy.sh 编写脚本12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env sh# set -enpm run buildecho &quot;打包完成&quot;# https://blog.csdn.net/yifeng4321/article/details/70232436 //更多判断文件# if [ !-d $dist ];then# echo &quot;文件夹存在&quot;# npm run build# else# echo &quot;文件夹不存在&quot;# ficd distgit initgit add .git commit -m &quot;commit message&quot;git remote add origin 您的git仓库echo &quot;关联远程库&quot;git pull --rebase origin masterecho &quot;获取远程库与本地同步合并&quot;git push -u origin master# 子目录/* 表示子目录下的所有文件# mv wolveq.github.io/* ./cd - 设置package.json在packa.json增加一条命令脚本 12345&#123; &quot;scripts&quot;: &#123; &quot;deploy&quot;: &quot;bash deploy.sh&quot; &#125;,&#125; 执行打包命令1npm run deploy 即可自动构建部署到git仓库/github上。]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>shell脚本</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则有关方法]]></title>
    <url>%2F2018%2F11%2F12%2F%E6%AD%A3%E5%88%99%E6%9C%89%E5%85%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[正则的方法和与正则有关的方法 共有6个，字符串实例4个，正则实例2个： 1234567891011String#searchString#splitString#matchString#replaceRegExp#testRegExp#exec 1.search() 定义：正则去匹配字符串，如果匹配成功，就返回匹配成功的位置，匹配失败就返回-1. 例子： 1234var regex = /\d/;var string = "abc123";console.log( string.search(regex) );// =&gt; 3 2.split 定义：split()方法把原字符串分割成子字符串组成数组，并返回该数组。 语法：str.split(separator, limit) 两个参数均是可选的，其中 separator 表示分隔符，它可以是字符串也可以是正则表达式。如果忽略 separator，则返回的数组包含一个由原字符串组成的元素。如果 separator 是一个空串，则 str 将会被分割成一个由原字符串中字符组成的数组。limit 表示从返回的数组中截取前 limit 个元素，从而限定返回的数组长度。 1234567var regex = /\D/console.log( "2017/06/26".split(regex) )console.log( "2017.06.26".split(regex) )console.log( "2017-06-26".split(regex) )// =&gt; ["2017", "06", "26"]// =&gt; ["2017", "06", "26"]// =&gt; ["2017", "06", "26"] 3.match 定义：match() 方法用于测试字符串是否支持指定正则表达式的规则，即使传入的是非正则表达式对象，它也会隐式地使用new RegExp(obj)将其转换为正则表达式对象。 语法：str.match(regexp) 该方法返回包含匹配结果的数组，如果没有匹配项，则返回 null 匹配原则：匹配成功就会结束，如果想继续全部匹配，加标识g 描述 若正则表达式没有 g 标志，则返回同 RegExp.exec(str) 相同的结果。而且返回的数组拥有一个额外的 input 属性，该属性包含原始字符串，另外该数组还拥有一个 index 属性，该属性表示匹配字符串在原字符串中索引（从0开始）。 若正则表达式包含 g 标志，则该方法返回一个包含所有匹配结果的数组，没有匹配到则返回 null。 12345var regex = /^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;)$/;var string = "2017-06-26";console.log( string.match(regex) );// =&gt;["2017-06-26", "2017", "06", "26", index: 0, input: "2017-06-26"]// =&gt; 3 4.replace 语法：str.replace( regexp | substr, newSubStr | function[, flags] ) 参数： regexp: 一个 RegExp 对象. 该正则所匹配的内容会被第二个参数的返回值替换掉。 substr: 一个要被 newSubStr 替换的字符串. newSubStr: 替换掉第一个参数在原字符串中的匹配部分. 该字符串中可以内插一些特殊的变量名. function: 一个用来创建新子字符串的函数, 该函数的返回值将替换掉第一个参数匹配到的结果. 该函数的参数描-述请参考 指定一个函数作为参数 小节. flags: 注意：flags 参数在 v8 内核（Chrome and NodeJs）中不起作用. 方法中使用 flags 参数不是符合标准的并且不赞成这样做. 5.test 说明：正则去匹配字符串，匹配成功，返回true，匹配失败，返回false 案例： 1234var regex = /\d/;var string = "abc123";console.log( regex.test(string) );// =&gt; true More info: Generating More info: Writing More info: Server 这篇文章对正则的细枝末节都有详细的介绍，我摘抄了部分重要的代码，和总结了6个方法。 剩下的匹配规则、关键字等，以后会一一补充。]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOs下安装nginx]]></title>
    <url>%2F2018%2F09%2F30%2FCentOs%E4%B8%8B%E5%AE%89%E8%A3%85nginx%2F</url>
    <content type="text"><![CDATA[前言lsb_release -a //查看Linux系统版本 (适用于所有的linux，包括Redhat、SuSE、Debian等发行版，但是在debian下要安装lsb) 安装nginx 基础运行环境 123456789yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel或者 yum install gcc yum install pcre-devel yum install zlib zlib-devel yum install openssl openssl-devel 2：切换目录：cd /usr/local3：创建文件夹：mkdir nginx 并 cd nginx4：下载nginx：wget http://nginx.org/download/nginx-1.13.7.tar.gz5：解压：tar -xvf nginx-1.13.7.tar.gz6：切换目录：cd nginx-1.13.77：make install8：查看nginx进程 ps -ef | grep nginx Nginx指令无法使用，问题如下 vim /etc/profile 进入文件进行编辑‘/usr/local/nginx/sbin’ 代表nginx的安装位置 新增以下PATH source /etc/profile 让配置文件重新生效一下 nginx命令不生效 vi /etc/init.d/nginx 插入以下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#!/bin/sh## nginx - this script starts and stops the nginx daemon## chkconfig: - 85 15# description: NGINX is an HTTP(S) server, HTTP(S) reverse \# proxy and IMAP/POP3 proxy server# processname: nginx# config: /etc/nginx/nginx.conf# config: /etc/sysconfig/nginx# pidfile: /var/run/nginx.pid# Source function library.. /etc/rc.d/init.d/functions# Source networking configuration.. /etc/sysconfig/network# Check that networking is up.[ &quot;$NETWORKING&quot; = &quot;no&quot; ] &amp;&amp; exit 0nginx=&quot;/usr/local/nginx/sbin/nginx&quot;prog=$(basename $nginx)NGINX_CONF_FILE=&quot;/usr/local/nginx/conf/nginx.conf&quot;[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginxlockfile=/var/lock/subsys/nginxmake_dirs() &#123; # make required directories user=`$nginx -V 2&gt;&amp;1 | grep &quot;configure arguments:.*--user=&quot; | sed &apos;s/[^*]*--user=\([^ ]*\).*/\1/g&apos; -` if [ -n &quot;$user&quot; ]; then if [ -z &quot;`grep $user /etc/passwd`&quot; ]; then useradd -M -s /bin/nologin $user fi options=`$nginx -V 2&gt;&amp;1 | grep &apos;configure arguments:&apos;` for opt in $options; do if [ `echo $opt | grep &apos;.*-temp-path&apos;` ]; then value=`echo $opt | cut -d &quot;=&quot; -f 2` if [ ! -d &quot;$value&quot; ]; then # echo &quot;creating&quot; $value mkdir -p $value &amp;&amp; chown -R $user $value fi fi done fi&#125;start() &#123; [ -x $nginx ] || exit 5 [ -f $NGINX_CONF_FILE ] || exit 6 make_dirs echo -n $&quot;Starting $prog: &quot; daemon $nginx -c $NGINX_CONF_FILE retval=$? echo [ $retval -eq 0 ] &amp;&amp; touch $lockfile return $retval&#125;stop() &#123; echo -n $&quot;Stopping $prog: &quot; killproc $prog -QUIT retval=$? echo [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile return $retval&#125;restart() &#123; configtest || return $? stop sleep 1 start&#125;reload() &#123; configtest || return $? echo -n $&quot;Reloading $prog: &quot; killproc $nginx -HUP RETVAL=$? echo&#125;force_reload() &#123; restart&#125;configtest() &#123; $nginx -t -c $NGINX_CONF_FILE&#125;rh_status() &#123; status $prog&#125;rh_status_q() &#123; rh_status &gt;/dev/null 2&gt;&amp;1&#125;case &quot;$1&quot; in start) rh_status_q &amp;&amp; exit 0 $1 ;; stop) rh_status_q || exit 0 $1 ;; restart|configtest) $1 ;; reload) rh_status_q || exit 7 $1 ;; force-reload) force_reload ;; status) rh_status ;; condrestart|try-restart) rh_status_q || exit 0 ;; *) echo $&quot;Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;&quot; exit 2esac 注册 nginx 服务 1234chmod +x /etc/init.d/nginxchkconfig --add nginxchkconfig --level 2345 nginx onchkconfig --list nginx 使用service 检查nginx配置 123service nginx test 检查service nginx start 启动service nginx reload 重启 开启防火墙的端口号 vi /etc/sysconfig/iptables 添加允许8088端口号出站 ,如下图 service iptables restart //重启防火墙 centos 命令不能用 command not found 在命令行中输入：export PATH=/usr/bin:/usr/sbin:/bin:/sbin 这样可以保证命令行命令暂时可以使用。命令执行完之后先不要关闭终端。 source /etc/profile]]></content>
      <categories>
        <category>Linux</category>
        <category>CentOs</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue入门到精通]]></title>
    <url>%2F2018%2F05%2F07%2FVue%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%2F</url>
    <content type="text"><![CDATA[前言本文以前端面试官的角度出发，对 Vue 框架中一些重要的特性、框架的原理以问题的形式进行整理汇总，意在帮助作者及读者自测下 Vue 掌握的程度。 1、说说你对 SPA 单页面的理解，它的优缺点分别是什么？SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。 优点： 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染； 基于上面一点，SPA 相对对服务器压力小； 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理； 缺点： 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载； 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理； SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。 2、v-show 与 v-if 有什么区别？v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。 所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。 3、Class 与 Style 如何动态绑定？ Class 可以通过对象语法和数组语法进行动态绑定： 对象语法： 123456&lt;div :class=&quot;&#123; active: isActive, &apos;text-danger&apos;: hasError &#125;&quot;&gt;&lt;/div&gt;data: &#123; isActive: true, hasError: false&#125; 数组语法： 123456&lt;div :class=&quot;[isActive ? activeClass : &apos;&apos;, errorClass]&quot;&gt;&lt;/div&gt;data: &#123; activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos;&#125; Style 也可以通过对象语法和数组语法进行动态绑定： 对象语法：123456&lt;div :style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;data: &#123; activeColor: &apos;red&apos;, fontSize: 30&#125; 数组语法： 12345678910&lt;div :style=&quot;[styleColor, styleSize]&quot;&gt;&lt;/div&gt;data: &#123; styleColor: &#123; color: &apos;red&apos; &#125;, styleSize:&#123; fontSize:&apos;23px&apos; &#125;&#125; 4、怎样理解 Vue 的单向数据流？所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定 ：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。 额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit派发一个自定义事件，父组件接收到后，由父组件修改。 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值： 123456props: [&apos;initialCounter&apos;],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125; 这个 prop 以一种原始的值传入且需要进行转换。 在这种情况下，最好使用这个 prop 的值来定义一个计算属性 123456props: [&apos;size&apos;],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; 5、computed 和 watch 的区别和运用的场景？computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值； watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作； 运用场景： 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算； 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 6、直接给一个数组项赋值，Vue 能检测到变化吗？由于 JavaScript 的限制，Vue 不能检测到以下数组的变动 7、谈谈你对 Vue 生命周期的理解？1、creating 状态–vue 实例被创建的过程2、mounting 状态–挂到到真实的 DOM 节点3、updating 状态–如果 data 中的数据改变就会触发对应组件的重新渲染4、destroying 状态–实例销毁 方法名 状态 含义 beforeCreate creating 状态 实例创建之前调用 created creating 状态 实例创建成功，此时 data 中的数据显示出来了 beforeMount mounting 状态 数据中的 data 在模版中先占一个位置 mounted mounting 状态 模版中的 data 数据直接显示出来了 beforeUpdate updating 状态 当 data 数据发生变化调用，发生在虚拟 DOM 重新渲染和打补丁之前 updated updating 状态 数据更改导致的虚拟 DOM 重新渲染和打补丁 beforeDestroy destroying 状态 在 vue 实例销毁之前调用，此时实例任然可用 destroyed destroying 状态 在 vue 实例销毁之后调用 8、在哪个生命周期内调用异步请求？可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点： 能更快获取到服务端数据，减少页面 loading 时间； ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性 9、在什么阶段才能访问操作DOM？mounted 10、父组件可以监听到子组件的生命周期吗？比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现： 1234567// Parent.vue&lt;Child @mounted=&quot;doSomething&quot;/&gt; // Child.vuemounted() &#123; this.$emit(&quot;mounted&quot;);&#125; 以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示： 123456789101112131415// Parent.vue&lt;Child @hook:mounted=&quot;doSomething&quot; &gt;&lt;/Child&gt;doSomething() &#123; console.log(&apos;父组件监听到 mounted 钩子函数 ...&apos;);&#125;, // Child.vuemounted()&#123; console.log(&apos;子组件触发 mounted 钩子函数 ...&apos;);&#125;, // 以上输出顺序为：// 子组件触发 mounted 钩子函数 ...// 父组件监听到 mounted 钩子函数 ... 当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。 11、谈谈你对 keep-alive 的了解？keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性： 一般结合路由和动态组件一起使用，用于缓存组件； 提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高； 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。 12、组件中 data 为什么是一个函数？为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？ 123456789101112131415// datadata() &#123; return &#123; message: &quot;子组件&quot;, childName:this.name &#125;&#125;// new Vuenew Vue(&#123; el: &apos;#app&apos;, router, template: &apos;&lt;App/&gt;&apos;, components: &#123;App&#125;&#125;) 因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。 13、v-model 的原理？我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件： text 和 textarea 元素使用 value 属性和 input 事件； checkbox 和 radio 使用 checked 属性和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 以 input 表单元素为例： 12345&lt;input v-model=&apos;something&apos;&gt; 相当于&lt;input v-bind:value=&quot;something&quot; v-on:input=&quot;something = $event.target.value&quot;&gt; 如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示： 1234567891011121314父组件：&lt;ModelChild v-model=&quot;message&quot;&gt;&lt;/ModelChild&gt;子组件：&lt;div&gt;&#123;&#123;value&#125;&#125;&lt;/div&gt;props:&#123; value: String&#125;,methods: &#123; test1()&#123; this.$emit(&apos;input&apos;, &apos;小红&apos;) &#125;,&#125;, 14、Vue 组件间通信有哪几种方式？3类通信：父子组件通信、隔代组件通信、兄弟组件通信（1）props / $emit 适用 父子组件通信（2）ref 与 $parent / $children 适用 父子组件通信（3）EventBus （$emit / $on） 适用于 父子、隔代、兄弟组件通信（4）$attrs/$listeners 适用于 隔代组件通信（5）provide / inject 适用于 隔代组件通信（6）Vuex 适用于 父子、隔代、兄弟组件通信 15、你使用过 Vuex 吗？Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。 主要包括以下几个模块： State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。 Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。 Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。 Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。 Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。 16、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？（1）hash 模式的实现原理 早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’： 1https://www.word.com#search hash 路由模式的实现主要是基于下面几个特性： URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送； hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换； 可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值； 我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。 （2）history 模式的实现原理 HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示： 12window.history.pushState(null, null, path);window.history.replaceState(null, null, path); history 路由模式的实现主要基于存在下面几个特性： pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ； 我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）； history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。 17、什么是 MVVM？（1）View 层 View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。 （2）Model 层 Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。 （3）ViewModel 层 18、Vue 是如何实现数据双向绑定的？Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示： 19、Vue 中的 key 有什么作用？key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端常用的nginx知识]]></title>
    <url>%2F2018%2F03%2F15%2F%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E7%9A%84nginx%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[前言由于前端技术的蓬勃发展和你自身的不断努力，很多小伙伴已经打通了任督二脉，做到了前后端通吃。你们就是自己程序世界里的神，在这里你们无所不能，创造世界，制定规则和逻辑。当一个属于你的世界做好后，你需要展示给朋友，发布于众人，让爱你的人欣赏。这时候我们需要一个强有力的服务器作为容器，而Nginx可以满足你的一切幻想;当然即便你还未打通任督二脉，作为一个前端，我相信你一定听说过Nginx。因为它在最近两年实在是太火了，作为一个前端如果不会Nginx，都不敢跟别人说自己是大前端。 Nginx的优点 支持海量高并发：采用IO多路复用epoll。官方测试Nginx能够支持5万并发链接，实际生产环境中可以支撑2-4万并发连接数。 内存消耗少：在主流的服务器中Nginx目前是内存消耗最小的了，比如我们用Nginx+PHP，在3万并发链接下，开启10个Nginx进程消耗150M内存。 免费使用可以商业化：Nginx为开源软件，采用的是2-clause BSD-like协议，可以免费使用，并且可以用于商业。 配置文件简单：网络和程序配置通俗易懂，即使非专业运维也能看懂。当然它的有点还有很多，感兴趣的同学可以自行百度更多 基于apt-get(Ubuntu18.04.2)的方式安装Nginx我们可以先来查看一下是否已经存在，命令如下： 1ps -ef | grep nginx 如果出现类似下面的内容，说明nginx是存在的。 如果不存在 1sudo apt-get install nginx 检测Nginx的版本。 1nginx -v 查看Nginx的安装目录1whereis nginx nginx.conf文件解读进入etc/nginx目录下，然后用vim进行打开 12cd /etc/nginxvim nginx.conf 下面是文件的详细注释 123456789101112131415161718192021222324252627282930313233#运行用户，默认即是nginx，可以不进行设置user nginx;#Nginx进程，一般设置为和CPU核数一样worker_processes 1; #错误日志存放目录error_log /var/log/nginx/error.log warn;#进程pid存放位置pid /var/run/nginx.pid;events &#123; worker_connections 1024; # 单个后台进程的最大并发数&#125;http &#123; include /etc/nginx/mime.types; #文件扩展名与类型映射表 default_type application/octet-stream; #默认文件类型 #设置日志模式 log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; #nginx访问日志存放位置 sendfile on; #开启高效传输模式 #tcp_nopush on; #减少网络报文段的数量 keepalive_timeout 65; #保持连接的时间，也叫超时时间 #gzip on; #开启gzip压缩 include /etc/nginx/conf.d/*.conf; #包含的子配置项位置和文件 进入conf.d目录，然后使用sudo vim /etc/nginx/sites-available/default 进行查看。 1234567891011121314151617181920212223242526272829303132333435363738394041424344server &#123; listen 80; #配置监听端口 server_name localhost; //配置域名 #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html; #服务默认启动目录 index index.html index.htm; #默认访问文件 &#125; #error_page 404 /404.html; # 配置404页面 # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; #错误状态码的显示页面，配置后需要重启 location = /50x.html &#123; root /usr/share/nginx/html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\.ht &#123; # deny all; #&#125;&#125; 到这里我们就可以浏览到程序的页面了,看到如下图片页面，说明你都配置成功了。 Nginx服务启动、停止、重启123sudo service nginx start 启动sudo service nginx reload , systemctl restart nginx.service 重启nginx -s quit , killall nginx , systemctl stop nginx.service 停止 自定义错误页和访问设置一个好的网站会武装到牙齿，任何错误都有给用户友好的提示。比如当网站遇到页面没有找到的时候，我们要提示页面没有找到，并给用户可返回性。错误的种类有很多，所以真正的好产品会给顾客不同的返回结果。 多错误指向一个页面在/etc/nginx/conf.d/default.conf 是可以看到下面这句话的。 1error_page 500 502 503 504 /50x.html; 单独为错误置顶处理方式有些时候是要把这些错误页面单独的表现出来，给用户更好的体验。所以就要为每个错误码设置不同的页面。设置方法如下： 1error_page 404 /404_error.html; 然后到网站目录下新建一个404_error.html 文件，并写入一些信息。 123456&lt;html&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;body&gt; &lt;h1&gt;404页面没有找到!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 然后重启我们的服务，再进行访问，你会发现404页面发生了变化。 把错误码换成一个地址处理错误的时候，不仅可以只使用本服务器的资源，还可以使用外部的资源。比如我们将配置文件设置成这样。 1error_page 404 https://baidu.com; 简单实现访问控制有时候我们的服务器只允许特定主机访问，比如内部OA系统，或者应用的管理后台系统，更或者是某些应用接口，这时候我们就需要控制一些IP访问，我们可以直接在location里进行配置。 可以直接在default.conf里进行配置。 1234location / &#123; deny 123.9.51.42; allow 45.76.202.231; &#125; 配置完成后，重启一下服务器就可以实现限制和允许访问了。这在工作中非常常用，一定要好好记得。 Nginx访问权限详讲指令优先级1234location / &#123; allow 45.76.202.231; deny all;&#125; 上面的配置表示只允许45.76.202.231进行访问，其他的IP是禁止访问的。但是如果我们把deny all指令，移动到 allow 45.76.202.231之前，会发生什么那？会发现所有的IP都不允许访问了。这说明了一个问题：就是在同一个块下的两个权限指令，先出现的设置会覆盖后出现的设置（也就是谁先触发，谁起作用）。 复杂访问控制权限匹配在工作中，访问权限的控制需求更加复杂，例如，对于网站下的img（图片目录）是运行所有用户访问，但对于网站下的admin目录则只允许公司内部固定IP访问。这时候仅靠deny和allow这两个指令，是无法实现的。我们需要location块来完成相关的需求匹配。 123456location =/img&#123; allow all;&#125;location =/admin&#123; deny all;&#125; =号代表精确匹配，使用了=后是根据其后的模式进行精确匹配。这个直接关系到我们网站的安全，一定要学会。 使用正则表达式设置访问权限只有精确匹配有时是完不成我们的工作任务的，比如现在我们要禁止访问所有php的页面，php的页面大多是后台的管理或者接口代码，所以为了安全我们经常要禁止所有用户访问，而只开放公司内部访问的。 123location ~\.php$ &#123; deny all;&#125; 这样我们再访问的时候就不能访问以php结尾的文件了。是不是让网站变的安全很多了那？ Nginx设置虚拟主机虚拟主机是指在一台物理主机服务器上划分出多个磁盘空间，每个磁盘空间都是一个虚拟主机，每台虚拟主机都可以对外提供Web服务，并且互不干扰。在外界看来，虚拟主机就是一台独立的服务器主机，这意味着用户能够利用虚拟主机把多个不同域名的网站部署在同一台服务器上，而不必再为简历一个网站单独购买一台服务器，既解决了维护服务器技术的难题，同时又极大地节省了服务器硬件成本和相关的维护费用。 基于端口号配置虚拟主机基于端口号来配置虚拟主机，算是Nginx中最简单的一种方式了。原理就是Nginx监听多个端口，根据不同的端口号，来区分不同的网站。 我们可以直接配置在主文件里etc/nginx/nginx.conf文件里， 也可以配置在子配置文件里etc/nginx/conf.d/default.conf。我这里为了配置方便，就配置在子文件里了。当然你也可以再新建一个文件，只要在conf.d文件夹下就可以了。 修改配置文件中的server选项，这时候就会有两个server。 123456server&#123; listen 8001; server_name localhost; root /usr/share/nginx/html/html8001; index index.html;&#125; 基于IP的虚拟主机基于IP和基于端口的配置几乎一样，只是把server_name选项，配置成IP就可以了。 比如上面的配置，我们可以修改为： 123456server&#123; listen 80; server_name 112.74.164.244; root /usr/share/nginx/html/html8001; index index.html;&#125; Nginx使用域名设置虚拟主机把原来的80端口虚拟主机改为以域名划分的虚拟主机。代码如下： 1234server &#123; listen 80; server_name nginx.youSiteName.com;&#125; 我们再把同目录下的8001.conf文件进行修改，改成如下： 12345678server&#123; listen 80; server_name nginx2.youSiteName.com; location / &#123; root /usr/share/nginx/html/html8001; index index.html index.htm; &#125;&#125; 然后我们用平滑重启的方式，进行重启，这时候我们在浏览器中访问这两个网页。(前提的有域名并解析所要配置的二级域名) Nginx反向代理的设置123456789101112location ~/api &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #proxy_set_header Host $http_host; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header Host $host:$server_port; proxy_set_header X-Nginx-Proxy true; proxy_redirect off; proxy_pass http://xxx; &#125; “~/api”以/api的请求，“http://xxx”需要代理的接口地址 反向代理还有些常用的指令， proxy_set_header :在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。 proxy_connect_timeout:配置Nginx与后端代理服务器尝试建立连接的超时时间。 proxy_read_timeout : 配置Nginx向后端服务器组发出read请求后，等待相应的超时时间。 proxy_send_timeout：配置Nginx向后端服务器组发出write请求后，等待相应的超时时间。 proxy_redirect :用于修改后端服务器返回的响应头中的Location和Refresh。 Nginx适配PC或移动设备现在很多网站都是有了PC端和H5站点的，因为这样就可以根据客户设备的不同，显示出体验更好的，不同的页面了。 这样的需求有人说拿自适应就可以搞定，比如我们常说的bootstrap和24格布局法，这些确实是非常好的方案，但是无论是复杂性和易用性上面还是不如分开编写的好，比如我们常见的淘宝、京东……这些大型网站就都没有采用自适应，而是用分开制作的方式。 $http_user_agent的使用：1234567891011server&#123; listen 80; server_name youSiteName.com; location / &#123; root /usr/share/nginx/pc; if ($http_user_agent ~* &apos;(Android|webOS|iPhone|iPod|BlackBerry)&apos;) &#123; root /usr/share/nginx/mobile; &#125; index index.html; &#125;&#125; Nginx的Gzip压缩配置Gzip是网页的一种网页压缩技术，经过gzip压缩后，页面大小可以变为原来的30%甚至更小。更小的网页会让用户浏览的体验更好，速度更快。gzip网页压缩的实现需要浏览器和服务器的支持。 gzip的配置项Nginx提供了专门的gzip模块，并且模块中的指令非常丰富。 gzip : 该指令用于开启或 关闭gzip模块。 gzip_buffers : 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。 gzip_comp_level : gzip压缩比，压缩级别是1-9，1的压缩级别最低，9的压缩级别最高。压缩级别越高压缩率越大，压缩时间越长。 gzip_disable : 可以通过该指令对一些特定的User-Agent不使用压缩功能。 gzip_min_length:设置允许压缩的页面最小字节数，页面字节数从相应消息头的Content-length中进行获取。 gzip_http_version：识别HTTP协议版本，其值可以是1.1.或1.0. gzip_proxied : 用于设置启用或禁用从代理服务器上收到相应内容gzip压缩。 gzip_vary : 用于在响应消息头中添加Vary：Accept-Encoding,使代理服务器根据请求头中的Accept-Encoding识别是否启用gzip压缩。 123456http &#123; ..... gzip on; gzip_types text/plain application/javascript text/css; .....&#125; nginx文件上传修改默认大小(10M =&gt; 300M)123client_max_body_size 300M;client_header_buffer_size 1280000k;large_client_header_buffers 4000000 12800000k; 如图：]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs微信支付之扫码支付]]></title>
    <url>%2F2018%2F03%2F08%2Fnodejs%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E4%B9%8B%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[开发环境 nodejs v8.1.0 egg v1.1.0 准备工作 微信公众号-appid 微信商户号-mch_id key值(签名算法所需,其实就是一个32位的密码，可以用md5生成一个)(key设置路径：微信商户平台(pay.weixin.qq.com)–&gt;账户设置–&gt;API安全–&gt;密钥设置) 扫码支付-统一下单123456789101112131415let MD5 = require(&apos;md5&apos;), xml2js = require(&apos;xml2js&apos;), url = &quot;https://api.mch.weixin.qq.com/pay/unifiedorder&quot;,// 下单请求地址 appid = &apos;公众号id&apos;, mch_id = &apos;微信商户号&apos;； notify_url = &apos;回调地址&apos;, out_trade_no = &apos;自己设置的订单号&apos;,// 微信会有自己订单号、我们自己的系统需要设置自己的订单号 total_fee = &apos;订单金额&apos;,// 注意，单位为分 body = &apos;商品简单描述&apos;, trade_type = &apos;NATIVE&apos;,// 交易类型，JSAPI--公众号支付、NATIVE--原生扫码支付、APP--app支付 nonce_str = moment().format(&apos;YYYYMMDDHHmmssSSS&apos;),// 随机字符串32位以下 stringA = `appid=$&#123;公众号id&#125;&amp;body=$&#123;body&#125;&amp;mch_id=$&#123;微信商户号&#125;&amp;nonce_str=$&#123;nonce_str&#125;&amp;notify_url=$&#123;notify_url&#125;&amp;out_trade_no=$&#123;out_trade_no&#125;&amp;spbill_create_ip=$&#123;ctx.request.ip&#125;&amp;total_fee=$&#123;total_fee&#125;&amp;trade_type=$&#123;trade_type&#125;`, stringSignTemp = stringA + &quot;&amp;key=xxxxxxxxxxxxxxxxx&quot;, //注：key为商户平台设置的密钥key sign = MD5(stringSignTemp).toUpperCase(); //注：MD5签名方式 以上就是我们所需要的一些参数签名生成算法见微信官方spbill_create_ip 是 终端ip地址 下面把所有的参数拼接成xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const formData = &quot;&lt;xml&gt;&quot;; formData += &quot;&lt;appid&gt;&quot; + appid + &quot;&lt;/appid&gt;&quot;; //appid formData += &quot;&lt;body&gt;&quot; + body + &quot;&lt;/body&gt;&quot;; //商品或支付单简要描述 formData += &quot;&lt;mch_id&gt;&quot; + mch_id + &quot;&lt;/mch_id&gt;&quot;; //商户号 formData += &quot;&lt;nonce_str&gt;&quot; + nonce_str + &quot;&lt;/nonce_str&gt;&quot;; //随机字符串，不长于32位 formData += &quot;&lt;notify_url&gt;&quot; + notify_url + &quot;&lt;/notify_url&gt;&quot;; //支付成功后微信服务器通过POST请求通知这个地址 formData += &quot;&lt;out_trade_no&gt;&quot; + out_trade_no + &quot;&lt;/out_trade_no&gt;&quot;; //订单号 formData += &quot;&lt;total_fee&gt;&quot; + total_fee + &quot;&lt;/total_fee&gt;&quot;; //金额 formData += &quot;&lt;spbill_create_ip&gt;&quot; + ctx.request.ip + &quot;&lt;/spbill_create_ip&gt;&quot;; //ip formData += &quot;&lt;trade_type&gt;NATIVE&lt;/trade_type&gt;&quot;; //NATIVE会返回code_url ，JSAPI不会返回 formData += &quot;&lt;sign&gt;&quot; + sign + &quot;&lt;/sign&gt;&quot;; formData += &quot;&lt;/xml&gt;&quot;; // 这里使用了egg里面请求的方式const resultData = yield ctx.curl(url, &#123; method: &apos;POST&apos;, content: formData, headers: &#123; &apos;content-type&apos;: &apos;text/html&apos;, &#125;, &#125;);// xml转json格式xml2js.parseString(resultData.data, function (err, json) &#123; if (err) &#123; new Error(&quot;解析xml报错&quot;) &#125; else &#123; var result = formMessage(json.xml); // 转换成正常的json 数据 console.log(result) //打印出返回的结果 &#125;&#125;) var formMessage = function (result) &#123; var message = &#123;&#125;; if (typeof result === &apos;object&apos;) &#123; var keys = Object.keys(result); for (var i = 0; i &lt; keys.length; i++) &#123; var item = result[keys[i]]; var key = keys[i]; if (!(item instanceof Array) || item.length === 0) &#123; continue; &#125; if (item.length === 1) &#123; var val = item[0]; if (typeof val === &apos;object&apos;) &#123; message[key] = formMessage(val); &#125; else &#123; message[key] = (val || &apos;&apos;).trim(); &#125; &#125; else &#123; message[key] = []; for (var j = 0, k = item.length; j &lt; k; j++) &#123; message[key].push(formMessage(itemp[j])); &#125; &#125; &#125; &#125; return message; &#125; 上面使用了egg的请求方式，node可以使用request 123456789var request = require(&apos;request&apos;);request(&#123; url: url, method: &quot;POST&quot;, body: formData&#125;, function(error, response, body) &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; &#125;&#125;); 如果请求成功会最终返回一个xml,然后我们进行解析成json的格式,里面会有一个code_url和out_trade_no,我们需要把这两个返回给前端，然后通过生成二维码展示给用户扫码，完成支付 监听支付是否成功上面操作完成之后，我们需要知道用户是否完成支付，因为用户会停留在该页面，我们需要在用户付完款之后，通知用户支付成功。首先，用户发起支付的时候我们会生成二维码，让用户完成扫码支付，我们还要做的是，开一个定时器，每隔一段时间去发送一个请求，这个时候，我们node后台就需要写一个查询订单的接口，之前我们拿到了out_trade_no，也就是我们系统内部的订单号，我们把这个数据发送给后台查询订单的接口，然后后台接收到之后会请求微信的查询接口地址https://api.mch.weixin.qq.com/pay/orderquery,流程跟上面一样，只是接口地址和微信返回的xml不一样而已，返回的字段会有一个状态即SUCCESS和NOTPAY，我们可以通过判断是否支付返回给前端，成功之后提示给用户支付成功，关闭定时器。 回调地址这个是非常重要的一环，大部分的操作其实在上面就可以完成，但是有特殊的情况，比如用户电脑断网发送不了请求，但是手机付款了，这就会导致我们记录不到用户支付的信息。这个时候回调地址就很重要了 设置回调地址 微信商户中心-&gt;产品中心-&gt;开发配置-&gt;扫码支付 之后我们需要做的是后端用post来接收微信发送的异步回调信息，也是xml的格式，这里注意，如果不支持接收xml，可能会得到空的数据这里还需要注意的是，我们在保存用户支付信息的同时，得先查改订单是否支付，以免重复操作，可能会插入多条记录的情况 总结微信扫码支付坑还是有的，如果你是第一次摸索的话，下面罗列一下需要注意的地方 签名算法要写正确，不然是不会成功的，要拼接正确才行 微信返回的是xml格式的数据，我们得通过插件转成json，这样才方便获取数据 返回的code_url要给前端生成二维码用，然后需要开一个定时器查询该订单是否完成支付，最终通知用户结果 回调地址很重要，我们后端需要post接收微信返回的回调信息，然后保存信息，不过在保存用户支付信息的之前，我们得知道该订单是否已经保存过，以免重复添加。还有就是返回的是xml的数据，后端一定要保证能够接收得到，按照正常的方式是接收不了的，得额外设置。]]></content>
      <categories>
        <category>微信支付</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>微信支付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue性能优化]]></title>
    <url>%2F2017%2F10%2F23%2FVue%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言 Vue 框架通过数据双向绑定和虚拟 DOM 技术，帮我们处理了前端开发中最脏最累的 DOM 操作部分， 我们不再需要去考虑如何操作 DOM 以及如何最高效地操作 DOM；但 Vue 项目中仍然存在项目首屏优化、Webpack 编译配置优化等问题，所以我们仍然需要去关注 Vue 项目性能方面的优化，使项目具有更高效的性能、更好的用户体验。本文是作者通过实际项目的优化实践进行总结而来，希望读者读完本文，有一定的启发思考，从而对自己的项目进行优化起到帮助。本文内容分为以下三部分组成： Vue 代码层面的优化； webpack 配置层面的优化； 基础的 Web 技术层面的优化。 一、代码层面的优化1.1、v-if 和 v-show 区分使用场景v-if 是 真正 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show 就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。 所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。 1.2、computed 和 watch 区分使用场景computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值； watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；运用场景： 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算； 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 1.3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-if（1）v-for 遍历必须为 item 添加 key在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。 （2）v-for 遍历避免同时使用 v-ifv-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。 推荐：1234567891011121314&lt;ul&gt; &lt;li v-for="user in activeUsers" :key="user.id"&gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt;computed: &#123; activeUsers: function () &#123; return this.users.filter(function (user) &#123; return user.isActive &#125;) &#125;&#125; 不推荐：12345678&lt;ul&gt; &lt;li v-for="user in users" v-if="user.isActive" :key="user.id"&gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 1.4、长列表性能优化Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。 123456789export default &#123; data:() =&gt; (&#123; users: &#123;&#125; &#125;), async created() &#123; const users = await axios.get("/api/users"); this.users = Object.freeze(users); &#125;&#125; 1.5、事件的销毁Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 如果在 js 内使用 addEventListene 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如： 123456created() &#123; addEventListener('click', this.click, false)&#125;,beforeDestroy() &#123; removeEventListener('click', this.click, false)&#125; 1.6、图片资源懒加载对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件：（1）安装插件 1npm install vue-lazyload --save-dev （2）在入口文件 main.js 中引入并使用 12import VueLazyload from &apos;vue-lazyload&apos;Vue.use(VueLazyload) （3）在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示： 1&lt;img v-lazy=&quot;/static/img/1.png&quot;&gt; 以上为vue-lazyload 插件的简单使用，如果要看插件的更多参数选项，可以查看 vue-lazyload 的 github地址。 1.7、路由懒加载Vue 是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。 路由懒加载：123456const Foo = () =&gt; import(&apos;./Foo.vue&apos;)const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/foo&apos;, component: Foo &#125; ]&#125;) 1.8、第三方插件的按需引入我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 element-ui 组件库为例：（1）首先，安装 babel-plugin-component ： 1npm install babel-plugin-component -D （2）然后，将 .babelrc 修改为： 123456789101112&#123; &quot;presets&quot;: [[&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;]], &quot;plugins&quot;: [ [ &quot;component&quot;, &#123; &quot;libraryName&quot;: &quot;element-ui&quot;, &quot;styleLibraryName&quot;: &quot;theme-chalk&quot; &#125; ] ]&#125; （3）在 main.js 中引入部分需要用到的组件： 12345import Vue from &apos;vue&apos;;import &#123; Button, Select &#125; from &apos;element-ui&apos;; Vue.use(Button) Vue.use(Select) 1.9、优化无限列表性能如果你的应用存在非常长或者无限滚动的列表，那么需要采用 窗口化 的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。你可以参考以下开源项目: &ensp;&ensp;vue-virtual-scroll-list 和 vue-virtual-scroller 来优化这种无限列表的场景的。 1.10、服务端渲染 SSR or 预渲染服务端渲染是指 Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染。（1）服务端渲染的优点： 更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面； 更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间； （2）服务端渲染的缺点： 更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境； 更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源，因此如果你预料在高流量环境下使用，请准备相应的服务器负载，并明智地采用缓存策略。 二、Webpack 层面的优化2.1、Webpack 对图片进行压缩在 vue 项目中除了可以在 webpack.base.conf.js 中 url-loader 中设置 limit 大小来对图片处理，对小于 limit 的图片转化为 base64 格式，其余的不做操作。所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 image-webpack-loader来压缩图片： （1）首先，安装 image-webpack-loader ： 1npm install image-webpack-loader --save-dev （2）然后，在 webpack.base.conf.js 中进行配置： 123456789101112131415161718&#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, use:[ &#123; loader: &apos;url-loader&apos;, options: &#123; limit: 10000, name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;) &#125; &#125;, &#123; loader: &apos;image-webpack-loader&apos;, options: &#123; bypassOnDebug: true, &#125; &#125; ]&#125; 2.2、减少 ES6 转为 ES5 的冗余代码在默认情况下， Babel 插件会在将 ES6 代码转换成 ES5 代码时会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过 require(‘babel-runtime/helpers/createClass’) 的方式导入，这样就能做到只让它们出现一次。babel-plugin-transform-runtime 插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。 （1）首先，安装 babel-plugin-transform-runtime ： 1npm install babel-plugin-transform-runtime --save-dev （2）然后，修改 .babelrc 配置文件为： 123&quot;plugins&quot;: [ &quot;transform-runtime&quot;] 如果要看插件的更多详细内容，可以查看babel-plugin-transform-runtime 的 详细介绍。 2.3、提取公共代码如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题： 相同的资源被重复加载，浪费用户的流量和服务器的成本。 每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。 所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。Webpack 内置了专门用于提取多个Chunk 中的公共部分的插件 CommonsChunkPlugin，我们在项目中 CommonsChunkPlugin 的配置如下： 123456789101112131415161718// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;vendor&apos;, minChunks: function(module, count) &#123; return ( module.resource &amp;&amp; /\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, &apos;../node_modules&apos;) ) === 0 ); &#125;&#125;),// 抽取出代码模块的映射关系new webpack.optimize.CommonsChunkPlugin(&#123; name: &apos;manifest&apos;, chunks: [&apos;vendor&apos;]&#125;) 如果要看插件的更多详细内容，可以查看 CommonsChunkPlugin 的 详细介绍。 2.4、模板预编译当使用 DOM 内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。 预编译模板最简单的方式就是使用单文件组件——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。 如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 vue-template-loader，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。 2.5、提取组件的 CSS当使用单文件组件时，组件内的 CSS 会以 style 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段 “无样式内容闪烁 (fouc) ” 。将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。 查阅这个构建工具各自的文档来了解更多： webpack + vue-loader ( vue-cli 的 webpack 模板已经预先配置好) Browserify + vueify Rollup + rollup-plugin-vue 2.6、优化 SourceMap我们在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩、去掉多余的空格、babel编译化后，最终将编译得到的代码会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有 bug的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发来说不好调式定位问题，因此 sourceMap 出现了，它就是为了解决不好调式代码问题的。 2.7、构建结果输出分析Webpack 输出的代码可读性非常差而且文件非常大，让我们非常头疼。为了更简单、直观地分析输出结果，社区中出现了许多可视化分析工具。这些工具以图形的方式将结果更直观地展示出来，让我们快速了解问题所在。接下来讲解我们在 Vue 项目中用到的分析工具：webpack-bundle-analyzer 。我们在项目中 webpack.prod.conf.js 进行配置： 1234if (config.build.bundleAnalyzerReport) &#123; var BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin; webpackConfig.plugins.push(new BundleAnalyzerPlugin());&#125; 执行 $ npm run build –report 后生成分析报告如下： 2.8、Vue 项目的编译优化详细介绍。 三、基础的 Web 技术优化3.1、开启 gzip 压缩gzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip。目前主流的浏览器，Chrome，firefox，IE等都支持该协议。常见的服务器如 Apache，Nginx，IIS 同样支持，gzip 压缩效率非常高，通常可以达到 70% 的压缩率，也就是说，如果你的网页有 30K，压缩之后就变成了 9K 左右 以下我们以服务端使用我们熟悉的 express 为例，开启 gzip 非常简单，相关步骤如下： 安装： 1npm install compression --save 添加代码逻辑： 123var compression = require(&apos;compression&apos;);var app = express();app.use(compression()) 重启服务，观察网络面板里面的 response header，如果看到如下红圈里的字段则表明 gzip 开启成功 ： 3.2、浏览器缓存为了提高用户加载页面的速度，对静态资源进行缓存是非常必要的，根据是否需要重新向服务器发起请求来分类，将 HTTP 缓存规则分为两大类（强制缓存，对比缓存），如果对缓存机制还不是了解很清楚的，可以参考作者写的关于 HTTP 缓存的文章《深入理解HTTP缓存机制及原理》，这里不再赘述。 3.3、CDN 的使用浏览器从服务器上下载 CSS、js 和图片等文件时都要和服务器连接，而大部分服务器的带宽有限，如果超过限制，网页就半天反应不过来。而 CDN 可以通过不同的域名来加载文件，从而使下载文件的并发连接数大大增加，且CDN 具有更好的可用性，更低的网络延迟和丢包率 。 3.4、使用 Chrome Performance 查找性能瓶颈Chrome 的 Performance 面板可以录制一段时间内的 js 执行细节及时间。使用 Chrome 开发者工具分析页面性能的步骤如下。 打开 Chrome 开发者工具，切换到 Performance 面板 点击 Record 开始录制 刷新页面或展开某个节点 点击 Stop 停止录制]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>服务端渲染SSR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue开源项目集合]]></title>
    <url>%2F2017%2F09%2F29%2Fvue%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[UI组件 element 饿了么出品的Vue2的web UI工具套件 Vux 基于Vue和WeUI的组件库 iview 基于 Vuejs 的开源 UI 组件库 mint-ui Vue 2的移动UI元素 muse-ui 三端样式一致的响应式 UI 库 vue-material 通过Vue Material和Vue 2建立精美的app应用 vuetify 为移动而生的Vue JS 2组件框架 Keen-UI - 轻量级的基本UI组件合集 vue-multiselect - Vue.js选择框解决方案 eme - 优雅的Markdown编辑器 bootstrap-vue 应用于Vuejs2的Twitter的Bootstrap 4组件 Vue.Draggable - 实现拖放和视图模型数组同步 eagle.js - hacker的幻灯片演示框架 vue-awesome-swiper - vue.js触摸滑动组件 vue-table - 简化数据表格 vue-chat - vuejs和vuex及webpack的聊天示例 vue-blu 帮助你轻松创建web应用 VueCircleMenu - 漂亮的vue圆环菜单 vue-infinite-scroll - VueJS的无限滚动指令 buefy - 响应式UI组件轻量级库 vue-beauty - 由vue和ant design创建的优美UI组件 vue-waterfall - Vue.js的瀑布布局组件 radon-ui - 快速开发产品的Vue组件库 vue-loop - 无限的内容循环 vue-chartjs - vue中的Chartjs的封装 vue-carbon ★684 - 基于 vue 开发MD风格的移动端 vue-syntax-highlight ★655 - Sublime Text语法高亮 vue-echarts ★649 - VueJS的ECharts组件 vue-quill-editor ★615 - 基于Quill适用于Vue2的富文本编辑器 vue-amap ★571 - 基于Vue 2和高德地图的地图组件 vue-calendar ★536 - 日期选择插件 vue-infinite-loading ★501 - VueJS的无限滚动插件 vue-swipe ★481 - VueJS触摸滑块 vue-music-player ★451 - Vuejs写一个音乐播放器 vue-scroller ★444 - Vonic UI的功能性组件 vue-datepicker ★436 - 日历和日期选择组件 vue-core-image-upload ★393 - 轻量级的vue上传插件 vue-progressbar ★379 - vue轻量级进度条 Gokotta ★375 - 简单的音乐播放器 vue-sortable ★373 - 轻松添加拖拽排序 vue-picture-input ★352 - 移动友好的图片文件输入组件 vue-echarts-v3 ★351 - VueJS组件封装 markcook ★343 - 好看的markdown编辑器 vue-video-player ★336 - VueJS视频及直播播放器 vue-google-maps ★334 - 带有双向数据绑定Google地图组件 vue-trend ★332 - 简单优雅的星光线条 vuejs-datepicker ★314 - vue日期选择器组件 vue-fullcalendar ★313 - 基于vue.js的全日历组件 vue-html5-editor ★303 - html5所见即所得编辑器 vue-upload-component ★298 - Vuejs文件上传组件 DataVisualization ★298 - 数据可视化 vue-tables-2 ★291 - 显示数据的bootstrap样式网格 VueStar ★270 - 带星星动画的vue点赞按钮 vue-data-tables ★266 - VueJS2数据表格 vue-paginate ★261 - 分页数据的简约VueJS插件 vue-ydui ★247 - 基于Vue2的移动端和微信UI vue-mugen-scroll ★239 - 无限滚动组件 vue-virtual-scroller ★238 - 带任意数目数据的顺畅的滚动 vue2-calendar ★236 - 支持lunar和日期事件的日期选择器 vue-dropzone ★233 - 用于文件上传的Vue组件 vue2-douban-market ★233 - 仿豆瓣市集webapp项目 vue-js-modal ★228 - 移动友好的Vuejs2的modal vue-slider ★224 - vue 滑动组件 vue-datetime-picker ★224 - 日期时间选择控件 rubik ★217 - 基于Vuejs2的开源 UI 组件库 vue-datasource ★210 - 创建VueJS动态表格 vue-image-crop-upload ★205 - vue图片剪裁上传组件 Vueditor ★204 - 所见即所得的编辑器 mint-loadmore ★203 - VueJS的双向下拉刷新组件 vue-slider-component ★202 - 在vue1和vue2中使用滑块 vue-chat ★200 - Vue全家桶+Socket.io+Express/Koa2打造一个智能聊天室 mavonEditor ★179 - 基于Vue的markdown编辑器 vue-carousel-3d ★173 - VueJS的3D轮播组件 vue-baidu-map ★170 - 基于 Vue 2的百度地图组件库 sweet-modal-vue ★170 - 精美的点击提示对话框 vue-particles ★168 - 粒子背景的vue组件 vue-swiper ★167 - 易于使用的滑块组件 vue-simplemde ★166 - VueJS的Markdown编辑器组件 vue-slide ★161 - vue轻量级滑动组件 vue-dragula ★157 - 使拖放变得简单 vue-drag-and-drop-list ★156 - 创建排序列表的Vue指令 vue2-editor ★155 - HTML编辑器 vue-charts ★152 - 轻松渲染一个图表 vue-data-grid ★151 - VueJS复杂桌面交互示例 vuwe ★150 - 基于微信WeUI所开发的专用于Vue2的组件库 vue-progressive-image ★148 - Vue的渐进图像加载插件 vue-msgbox ★148 - vuejs的消息框 vue-lazyload-img ★147 - 移动优化的vue图片懒加载插件 vue-dragging ★146 - 使元素可以拖拽 vue-instant ★143 - 轻松创建自动提示的自定义搜索控件 vue-social-sharing ★142 - 社交分享组件 vue-images ★139 - 显示一组图片的lightbox组件 vue-impression ★134 - 移动Vuejs2 UI元素 vue-mdEditor ★131 - 基于VUE的markdown文本编辑器 vue-typer ★130 - 模拟用户输入选择和删除文本的Vue组件 vue-highcharts ★130 - HighCharts组件 vue-tooltip ★129 - 带绑定信息提示的提示工具 vue-svgicon ★127 - 创建svg图标组件的工具 wdui ★124 - 基于Vue2的UI组件库 vue2-loading-bar ★118 - 最简单的仿Youtube加载条视图 vue-tabs-component ★116 - 渲染tabs的Vue组件 MagicMusic ★113 - 不一样的音乐 vue-region-picker ★111 - 选择中国的省份市和地区 vue-datatable ★102 - 使用Vuejs创建的DataTableView vue-loading ★102 - 元素中加载block的Vue指令 vodal ★99 - 动画的vue模态 vue-img-inputer ★97 - 基于Vue2的图片输入框 vue-video ★96 - Vue.js的HTML5视频播放器 vue-touch-ripple ★95 - vuejs的触摸ripple组件 vue-event-calendar ★91 - 简单小巧的事件日历组件 v-bar ★91 - 虚拟响应跨浏览器滚动条 vue2-timepicker ★84 - 下拉时间选择器 vuejs-paginate ★80 - 分页VueJS组件 vue-toast-mobile ★79 - VueJS的toast插件 vue-datepicker ★78 - 漂亮的Vue日期选择器组件 vue-easy-slider ★77 - Vue 2.x的滑块组件 vue-float-label ★76 - VueJS浮动标签模式 vue-scrollbar ★76 - 最简单的滚动区域组件 vant ★74 - 有赞出品的Vue2.0移动UI vue-json-tree-view ★74 - Vue的JSON树视图 vue-slick ★73 - 实现流畅轮播框的vue组件 vue-keynote ★73 - 实现声明性代码幻灯片 vue-google-signin-button ★73 - 导入谷歌登录按钮 vue-rate ★68 - Vue评分组件 awesome-mask ★67 - 拥有独一无二mask的表单 vue-radial-progress ★65 - Vue.js放射性进度条组件 vue-quill ★65 - vue组件构建quill编辑器 vue-date-picker ★63 - VueJS日期选择器组件 coffeebreak ★62 - 实时编辑CSS组件工具 vue-good-wizard ★61 - VueJS 2.x wizard plugin vue-loading ★60 - 使用SVG加载 datepicker ★59 - 基于flatpickr的时间选择组件 vue-placeholders ★58 - 处理占位符图片和乱码 we-vue ★55 - Vue2及weui1开发的组件 vue-fullcalendar ★55 - vue FullCalendar封装 vue-chartkick ★53 - VueJS一行代码实现优美图表 cxlt-vue2-toastr ★52 - 弹出提示的Vue2组件 vue-formly ★51 - VueJS的JS表单 vue2-autocomplete ★51 - vue2的自动完成组件 vue-morris ★50 - Vuejs组件封装Morrisjs库 veui ★50 - VueJS百度企业UI vue-components ★49 - 移动端UI组件库 vue-star-rating ★49 - 简单高度自定义的星星评级组件 vue-tagsinput ★48 - 基于VueJS的标签组件 vue-tabs ★47 - 多tab页轻型框架 vue-popup-mixin ★47 - 用于管理弹出框的遮盖层 vue-ripple-directive ★45 - 使用Vue指令的Material波纹效果 vue-cropper ★42 - 一个简单的vue 的图片裁剪插件 vue-ztree ★41 - 用 vue 写的树层级组件 vue-touch-keyboard ★41 - VueJS虚拟键盘组件 cubeex ★40 - 包含一套完整的移动UI vue-chart ★40 - 强大的高速的vue图表解析 vue-music-master ★40 - vue手机端网页音乐播放器 vue-bootstrap-table ★39 - 可排序可检索的表格 vue-emoji ★39 - 好用的emoji插件 handsontable ★39 - 网页表格组件 vue-form-2 ★37 - 全面的HTML表单管理的解决方案 vue-area ★37 - 省市区三级联动插件 vue-side-nav ★37 - 响应式的侧边导航 vue-image-scroll ★36 - 仿网易云音乐的vue图片滚动插件 vue-pull-to-refresh ★35 - Vue2的上拉下拉 mint-indicator ★35 - VueJS移动加载指示器插件 vue-image-clip ★34 - 基于vue的图像剪辑组件 vue-material-design ★34 - Vue MD风格组件 vue-simple-upload ★31 - 简单的VueJS上传组件 chartjs ★29 - Vue Bulma的chartjs组件 vue-lazy-background-images ★29 - 懒加载背景组件的Vue组件 vue-ripple ★29 - 制作谷歌MD风格涟漪效果的Vue组件 vue-scroll ★27 - vue滚动 laravel-vue-pagination ★26 - VueJS分页组件 vue-datepicker-simple ★26 - 基于vue的日期选择器 vue-m-carousel ★26 - vue 移动端轮播组件 vue-parallax ★23 - 整洁的视觉效果 vue-img-loader ★22 - 图片加载UI组件 vue-tree ★22 - vue树视图组件 vue-verify-pop ★22 - 带气泡提示的vue校验插件 vue-waves ★22 - waves的VueJS版本 vue-smoothscroll ★20 - smoothscroll的VueJS版本 vue-city ★19 - 城市选择器 vue-laypage ★17 - 简单的VueJS分页组件 vue-typewriter ★15 - vue组件类型 vue-ios-alertview ★14 - iOS7+ 风格的alertview服务 vue-cmap ★14 - Vue China map可视化组件 paco-ui-vue ★12 - PACOUI的vue组件 vue-cascading-address ★9 - vue地区选择器 dd-vue-component ★7 - 订单来了的公共组件库 vue-button ★5 - Vue按钮组件 开发框架 vue.js ★56380 - 流行的轻量高效的前端组件化方案 vue-admin ★4612 - Vue管理面板框架 quasar ★2353 - 响应式网站和混合移动应用程序 electron-vue ★2085 - Electron及VueJS快速启动样板 vue-element-admin ★1986 - vue2管理系统模板 vuepack ★1618 - 现代VueJS启动器 N3-components ★656 - 快速构建页面和应用 VueThink ★373 - 前后端分离框架 vue-2.0-boilerplate ★358 - Vue2单页应用样板&#8203; vue-spa-template ★344 - 前后端分离后的单页应用开发 Framework7-Vue ★283 - VueJS与Framework7结合 vue-bulma ★215 - 轻量级高性能MVVM Admin UI框架 vuetiful ★189 - 创建业务及管理应用程序 vue-stack-2.0 ★155 - Vue2项目样板 vue2-admin-lte ★154 - vue2版本的adminLTE jspangAdmin ★140 - 基于Vue2的后台管理系统 vue-fullstack ★140 - 实时的用户友好的后台系统 vue-paper-dashboard ★120 - Vue的Tim Paper 仪表盘 vue-webgulp ★113 - 仿VueJS Vue loader示例 vue-element-starter ★83 - vue启动页 vuemin ★17 - 基于Vue的企业级前端开发框架 vue-team-template ★12 - 一种构建vue项目的选择方案 实用库 vuex ★8043 - 专为 Vue.js 应用程序开发的状态管理模式 vue-loader ★1847 - Vue.js 针对Webpack的组件装载插件 vue-validator ★1807 - vue的验证器插件 vue-lazyload ★1224 - 用于懒加载的Vue模块 vuelidate ★1075 - 简单轻量级的基于模块的Vue.js验证 vue-i18n ★1053 - VueJS的多语言切换插件 qingcheng ★736 - qingcheng主题 Vue-Socketio ★533 - VueJS的socketio实现 vue-awesome ★532 - VueJS字体Awesome组件 vue-desktop ★496 - 创建管理面板网站的UI库 vue-axios ★491 - 将axios整合到VueJS的封装 vue-meta ★467 - 管理app的meta信息 vue-head ★396 - head标签的meta信息操作 meteor-vue-component ★382 - vue和meteor整合 avoriaz ★338 - VueJS测试实用工具库 portal-vue ★239 - 在组件外部渲染DOM vue-flatpickr ★228 - 封装Flatpickr的Vue组件 vue-timeago ★195 - VueJS的时间前组件 blessed-vue ★181 - 编写命令行UI的VueJS运行时 vue-unit ★179 - 创建单元测试组件 vue-authenticate ★177 - 简单的VueJS身份认证库 vue-scrollTo ★174 - 滚动到元素的VueJS指令 vue-svg-icon ★157 - vue2的可变彩色svg图标方案 vue-focus ★148 - 可重用VueJS组件的焦点指令 meteor-vue ★134 - VueJS和Meteor的桥接 element-admin ★130 - 支持 vuecli 的 Element UI 的后台模板 vuep ★118 - 用实时编辑和预览来渲染Vue组件 vuet ★116 - 一个跨页面、跨组件的状态管理插件 vue-bootstrap-modal ★112 - vue的Bootstrap样式组件 vue-animate ★106 - 跨浏览器CSS3动画库 vue-property-decorator ★104 - VueJS和属性Decorator vue-aplayer ★100 - 便于配置的音乐播放器vue2组件 vue-password-strength-meter ★97 - 交互式密码强度计 vue-websocket ★91 - VueJS的Websocket插件 vue-local-storage ★88 - 具有类型支持的Vuejs本地储存插件 vue-recyclist ★88 - vuejs无限滚动列表 vue-lazy-render ★87 - 用于Vue组件的延迟渲染 vue-qart ★86 - 用于qartjs的Vue2指令 vue-framework7 ★85 - 结合VueJS使用的Framework7组件 vue-cordova ★85 - Cordova的VueJS插件 http-vue-loader ★84 - 从html及js环境加载vue文件 vue-parallax ★84 - 快速60fps视差滚动效果组件 vue-clipboard ★84 - VueJS的剪贴板 vue-kindergarten ★83 - 将kindergarten集成到VueJS应用 vue-events ★83 - 简化事件的VueJS插件 vue-notifications ★80 - 非阻塞通知库 vue-online ★77 - reactive的在线和离线组件 vue-shortkey ★74 - 应用于Vue.js的Vue-ShortKey 插件 vue-bus ★71 - VueJS的事件总线 vuex-i18n ★71 - 定位插件 uiv ★70 - Vue实现的Bootstrap组件 vue-router-transition ★69 - 页面过渡插件 vue-gesture ★69 - VueJS的手势事件插件 vue-clip ★67 - 简约的破解文件上传器 vue-electron ★66 - 将选择的API封装到Vue对象中的插件 cleave ★64 - 基于cleave.js的Cleave组件 vuemit ★63 - 处理VueJS事件 vue-worker ★56 - 使用webworkers的Vue插件 vue-acl ★54 - VueJS访问控制列表插件 vue-ts-loader ★54 - 在Vue装载机检查脚本 Vue.resize ★51 - 检测HTML调整大小事件的vue指令 vuedeux ★50 - 轻量级开源实用用层 vue-ls ★49 - 适配Vuecontext中LocalStorage的Vue插件 lazy-vue ★48 - 懒加载图片 vue-pagination-2 ★46 - 简单通用的分页组件 v-media-query ★44 - vue中添加用于配合媒体查询的方法 vue-observe-visibility ★42 - 当元素在页面上可见或隐藏时检测 vue-lazy-component ★38 - 懒加载组件或者元素的Vue指令 vue-reactive-storage ★37 - vue插件的Reactive层 vue-helmet ★37 - HTML标题管理器 voir ★35 - 保持mutation与视图组件的分离 vuex-shared-mutations ★34 - 分享某种Vuex mutations vue-drag-zone ★28 - 适用于Vue2的dom拖动组件 vue-eslint-parser ★27 - ESLint自定义解析 modal ★26 - Vue Bulma的modal组件 vue-plan ★25 - Vuex-状态管理 vue-file-base64 ★22 - 将文件转换为Base64的vue组件 vue-methods-promise ★21 - 使vue方法支持promise Vue.ImagesLoaded ★20 - 检测图片加载的VueJS指令 Famous-Vue ★16 - Famous库的vue组件 leo-vue-validator ★15 - 异步的表单验证组件 vue-titlecase ★13 - 用于字符串titlecased的VueJS过滤器 Vue-Easy-Validator ★12 - 简单的表单验证 vue-zoombox ★12 - 一个高级zoombox vue-truncate-filter ★10 - 截断字符串的VueJS过滤器 vue-router-storage ★9 - vue历史路由持久化的解决方案 vue-input-autosize ★9 - 基于内容自动调整文本输入的大小 vue-data-validator ★4 - Vuejs2的数据验证插件 vue-lazyloadImg ★4 - 图片懒加载插件 应用实例 koel ★7773 - 基于网络的个人音频流媒体服务 pagekit ★4225 - 轻量级的CMS建站系统 vue-manage-system ★2057 - 后台管理系统解决方案 vuedo ★1265 - 博客平台 jackblog-vue ★1120 - 个人博客系统 PJ Blog ★1018 - 开源博客 vue-cnode ★787 - 重写vue版cnode社区 vms ★629 - vuejs2管理系统 CMS-of-Blog ★541 - 博客内容管理器 goldfish ★518 - 用于HashiCorp Vault的Admin UI rss-reader ★368 - 简单的rss阅读器 vue-ghpages-blog ★254 - 依赖GitHub Pages无需本地生成的静态博客 vue-blog ★143 - 使用Vue2.0 和Vuex的vue-blog swoole-vue-webim ★137 - Web版的聊天应用 tomato5 ★134 - 实时的协作工具 Loopa-News ★133 - 开源社会新闻应用 vue2-management-platform ★74 - vue2.0+ elementUI 后台管理平台 vue-dashing-js ★70 - nuvo-dashing-js的fork fewords ★63 - 功能极其简单的笔记本 adminify ★46 - 一个基于Vuetify material的Admin面板 Demo示例 vue2-elm ★8036 - 重写饿了么webapp Vue-cnodejs ★2491 - 基于vue重写Cnodejs.org的webapp NeteaseCloudWebApp ★1549 - 高仿网易云音乐的webapp vue2-happyfri ★1535 - vue2及vuex的入门练习项目 vue-zhihu-daily ★1010 - 知乎日报 with Vuejs vue2-demo ★994 - 从零构建vue2 + vue-router + vuex 开发环境 vue-wechat ★939 - vue.js开发微信app界面 eleme ★882 - 高仿饿了么app商家详情 vue-demo ★755 - vue简易留言板 bilibili-vue ★694 - 全栈式开发bilibili首页 spa-starter-kit ★646 - 单页应用启动套件 VueDemo_Sell_Eleme ★636 - Vue2高仿饿了么外卖平台 vue-music ★621 - Vue 音乐搜索播放 douban ★606 - 基于vue全家桶的精致豆瓣DEMO vue-Meizi ★604 - vue最新实战项目 maizuo ★603 - vue/vuex/redux仿卖座网 vue-WeChat ★558 - 基于Vue2高仿微信App的单页应用 vue-demo-kugou ★500 - vuejs仿写酷狗音乐webapp vue2-manage ★457 - 基于 vue + element-ui 的后台管理系统 zhihudaily-vue ★455 - 知乎日报web版 vue-163-music ★448 - vue仿网易云音乐客户端版 vue-axios-github ★448 - 登录拦截登出功能 douban ★440 - 模仿豆瓣前端 vue-shopping ★404 - 蘑菇街移动端 vue2.0-taopiaopiao ★402 - vue2.0与express构建淘票票页面 xyy-vue ★396 - 大学生交流平台 easy-vue ★370 - 使用Vue实现简易web vue2.x-douban ★360 - Vue2实现简易豆瓣电影webApp vue2-MiniQQ ★351 - 基于Vue2实现的仿手机QQ单页面应用 mi-by-vue ★291 - VueJS仿小米官网 daily-zhihu ★275 - 基于Vue2的知乎日报单页应用 vue-leancloud-blog ★268 - 一个前后端完全分离的单页应用 VueMusic-PC ★260 - Vue.js高还原网易云音乐系列 node-vue-server-webpack ★253 - Node.js+Vue.js+webpack快速开发框架 beauty ★245 - 豆瓣美女clone vue-adminLte-vue-router ★243 - vue和adminLte整合应用 vue-fis3 ★217 - 流行开源工具集成demo notepad ★216 - 本地存储的记事本 vue-demo-maizuo ★210 - 使用Vue2全家桶仿制卖座电影 Pixel-Web ★198 - 一个 Vue 微博客户端 netease_yanxuan ★198 - vue版网易严选 tmdb-app ★194 - TMDbVueJS应用 vue-express-mongodb ★189 - 简单的前后端分离案例 vue-zhihudaily ★187 - 知乎日报 Web 版本 Vdo ★179 - VueJS与MD重构豆瓣 vue-blog ★171 - 单用户博客 Wuji ★168 - 吾记网页版 hello-vue-django ★160 - 使用带有Django的vuejs的样板项目 Zhihu-Daily-Vue.js ★157 - Vuejs单页网页应用 tencent-sports ★154 - Vue全家桶仿腾讯体育 gouyan-movie-vue ★151 - 基于vue的在线电影影讯网站 x-blog ★145 - 开源的个人blog项目 vue-musicApp ★132 - 使用vue全家桶制作的音乐播放器 vue-cnode ★131 - vue单页应用demo webpack-vue-vueRouter ★130 - webpack及vue开发的简单项目实例 vue-koa-demo ★128 - 使用Vue2和Koa1的全栈demo vueBlog ★127 - 前后端分离博客 websocket_chat ★127 - 基于vue和websocket的多人在线聊天室 houtai ★125 - 基于vue和Element的后台管理系统 vue-toutiao ★121 - vuejs高仿今日头条移动端 vue-cnode ★121 - 开源的CNode社区 vue-mini-shop ★121 - VueJS在线商店 photoShare ★120 - 基于图片分享的社交平台 iview2-management-system ★119 - 后台管理系统解决方案简单示例 doubanMovie ★119 - 豆瓣电影展示 eleme-vue2 ★112 - 仿饿了么H5纯前端Vue版 vue-zhihu-daily ★111 - 基于Vue全家桶开发的知乎日报 Vue-News ★107 - 基于vue全家桶的仿知乎日报单页应用 douban-movie ★107 - 仿豆瓣电影wap端 generator-loopback-vue ★104 - 典型前后端分离项目模板 vue-quasar-admin-example ★99 - 将Quasar和VueJS应用于SPA项目 vue-zhihudaily-2.0 ★97 - 使用Vue2.0+vue-router+vuex创建的zhihudaily vue-todos ★95 - vue最新实战项目教程 vue-music ★91 - 网易云音乐Demo vue-qqmusic ★90 - Vue全家桶+Mint-Ui打造高仿QQMusic vue2.x-Cnode ★88 - 基于vue全家桶的Cnode社区 vue-ruby-china ★86 - VueJS框架搭建的rubychina平台 doubanMovie-SSR ★85 - Vue豆瓣电影服务端渲染 vue-jd ★76 - 京东移动web商城 vue-nReader ★73 - 使用vue2.0 + vue-router + vuex 的一个多页面小说阅读webapp VueBlog ★73 - 前后端分离的个人博客 Zhihu_Daily ★73 - 基于Vue和Nodejs的Web单页应用 vue-koa2-login ★67 - 使用 VueJS &amp; NodeJS 实现的登录注册 webApp ★64 - Vue2的移动端webApp音乐播放器 vue-trip ★64 - vue2做的出行webapp seeMusic ★63 - 跨平台云音乐播放器 github-explorer ★63 - 寻找最有趣的GitHub库 vue-cli-multipage-bootstrap ★60 - 将vue官方在线示例整合到组件中 vue-XiaoMi-Shop ★59 - 高仿小米商城的项目 Vue-NetEaseCloudMusic ★59 - 模仿IOS版网易云音乐的手机网站 life-app-vue ★59 - 使用vue2完成多功能集合到小webapp doubanApp ★55 - 用vue2实现仿豆瓣app ios7-vue ★52 - 使用vue2.0 vue-router vuex模拟ios7 canvas-vue ★50 - 一个Vue+Cnavas酷炫后台管理 vue-bushishiren ★49 - 不是诗人应用 vue-ssr-boilerplate ★48 - 精简版的ofvue-hackernews-2 vuecommunity ★47 - vue.js中文社区 vue-music163 ★47 - 音乐VueJS项目 Vue2-MV ★45 - 仿网易云音乐MV的webapp musiccloudWebapp ★44 - 用vuejs仿网易云音乐 cnode-vue ★40 - 基于vue和vue-router构建的cnodejs web网站SPA Framework7-VueJS ★38 - 使用移动框架的示例 m-eleme ★37 - 基于Vue全家桶仿饿了么移动端webapp sls-vuex2-demo ★37 - vuex2商城购物车demo eagles ★36 - 各种组件封装 Todos_Vuejs ★35 - vuejs2搭建的极简的todolist vue-cnode ★35 - 用 Vue 做的 CNode 官网 HyaReader ★35 - 移动友好的阅读器 Vue-Admin ★33 - 基于Vue2的Admin系统 vue2-hybridapp-haoshiqi ★32 - 实现单页面webapp以及hybridapp zhihu-daily ★32 - 轻松查看知乎日报内容 gank ★32 - gankio资源的阅读应用 vue-h5plus ★31 - 前卫的vue及html5plus跨平台demo vue-cnode-mobile ★29 - 搭建cnode社区 vue-weather ★26 - 基于vue.js 2.0的百度天气应用 vue-user-center ★26 - vuejs直播类应用web端个人中心 zhihu-daily-vue ★22 - 知乎日报 vue-cnode ★22 - 使用cNode社区提供的接口 vue-starter ★22 - VueJs项目的简单启动页 node-vue-fabaocn ★21 - 基于 node 和 vue 实现的移动官网 vue-memo ★20 - 用 vue写的记事本应用 v-notes ★20 - 简单美观的记事本 vue-flexible-app ★19 - vue开发的一个简易app simply-calculator-vuejs ★19 - 用VueJS实现简易计算器 vue-dropload ★19 - 用以测试下拉加载与简单路由 Vuejs-SalePlatform ★19 - vuejs搭建的售卖平台demo vue-shopping-mall ★16 - 基于Vue.js 2.x系列 + vue2-router + axios + iview 商城 qqmusic ★13 - QQ音乐vue vue-weather ★12 - VueJS天气demo]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
